---
title: "Working with the Tidyverse"
output: html_notebook
---

We're going to practice using some of the functions in the `dplyr` library. First, lets install the `tidyverse` packages
```{r}
install.packages('tidyverse')
```

```{r}
library(tidyverse)
```

You will be using the pipe function all lot; I recommend setting a key board short cut for it. Go to Tools > modify keyboard search cuts > search for "pipe"  >  click to change the command. I find `alt + 2` or `option + 2` work well.

load the `dplyr` library

- `select` select columns from a dataframe
- `filter` subset a dataframe based on a logical operator or vector
- `mutate` to add or change columns in a data frame
- `arrange` to sort a dataframe based on a column
- `pull` extract a column from a dataframe as a vector


```{r}
library(dplyr)

```

we'll be working with the `starwars` dataset

```{r}
data("starwars")
starwars
```

Select the `name` column from the `starwars` dataset. Store this in a variable 

```{r}
name_selected <-  select(starwars, name)
```

now `pull` the `name` column from the dataset. store this in a variable

```{r}
name_pulled <- pull(starwars, name)
name_pulled
```
Notice the differences in the returned data. use `class` to examine both outputs 
```{r}
class(name_selected)
```
select the name and height columns 
```{r}

select(starwars, name, height)
```


 Using pipes to add to the previous command,  add a column with the height in inches.  the height column is currently in cm and  1 cm is 0.393701 inches 
```{r}
starswars_height_inches <-  starwars %>% select( name, height) %>% mutate(height_inches = height *0.393701 )
```

filter the starwars dataframe to get every person who has blue eyes 

```{r}
starwars %>% filter(eye_color == 'blue')
```

filter the starwars dataframe to get rows whose homeworld is either Tatooine or Naboo	
hint use %in%
```{r}


```


```{r}

starwars %>% 
    group_by(eye_color, sex) %>% 
    summarise(averge_height = mean(height))

```




## Example - GTF file

- a GTF file contains information about the location of genes within the genome, as well as vartiety of other annotations. `../src/gtf_example.tsv.gz` contains 5 genes. 
- Each gene has multiple transcripts, and each transcript has a protein coding region, or CDS.  read this data in, and use functions from the tidyverse to calculate the length of each CDS, and determine the gene with the longest CDS. Generaly workflow  
read the data  >  select values that only correspond the to CDS(look at the `type` column)  >  for each CDS group together and calculate the smallest start and the largest end( the `transcript_id` column is unique for each CDS ) >  largest end - smallest start  = length

```{r}


```


1. filter this data to just CDS entries for the `type` column
2. select the following columns : type, transcript_id, start, end
3. group the filtered data by transcript_id, 
4. summarise the data to select the smallest start and largest end for each CDS 
    - `min` - selects the smallest value from a vector
    - `max` - selects 
5. with the summarised data frame, calculate(with mutate) the length of each CDS (end -start)
6. arrange data by the length is decreasinng order largest. 

```{r}
library(tidyverse)
library(readr)
gtf <-  read_tsv('../src/gtf_example.tsv.gz')

gtf %>% 
    filter(type == 'CDS') %>% 
    select(type, transcript_id, start, end) %>% 
    group_by(transcript_id) %>% 
    summarise(s_start = min(start), 
              l_end = max(end)) %>% 
    mutate(length = l_end - s_start) %>% 
    arrange(desc(length))

```


## reshaping data

practice going from wide to long format using the pivot_longer function, using the economics data frame


```{r}
data("economics")
pivot_longer(
    data = economics,
    cols = c(pce, pop, psavert, uempmed, unemploy),
    names_to = 'observation_names',
    values_to = 'observation_values'
)

```

## Tying it all together

- the file  "../src/tx_expression_subset.tsv.gz" has some data from a real RNA-seq experiment and contains transcript expression values; there is a column for transcript name, and the rest of the columns are the samples each transcript is expressed in. 

- Using the gene to transcript id mapping present in the gtf file from above, add gene names to this expression data, and select the genes DCX , GRM3 , MYO7A. summarise the transcript level expression to gene level, and make box plots for  the expression of each gene expression. 

- create a data frame that maps each gene_name to a transcript_id using the gtf we loaded earlier. selecting gene_name and transcript_id columns,  removinng duplicated rows 



```{r}

tx_exp <- read_tsv('../src/tx_expression_subset.tsv.gz')


```
 
```{r}
tx2gene <- gtf %>% select(gene_name, transcript_id) %>% distinct %>% filter(!is.na(transcript_id))


```
 



join tx2gene and the data we read in together, with tx2gene left side, and the expression data on the right hand side ex inner_join(gtf_gene, gtf_transcript)
```{r}

tx2gene %>% inner_join(tx_exp)

```
 

- remove the transcript id column, and convert the data from wide to long,

```{r}
tx2gene %>% inner_join(tx_exp) %>% 
    select(-transcript_id) %>% 
    pivot_longer(cols = -gene_name, 
                 names_to = 'sample_id',
                 values_to = 'expression')
```


- groupby and summarise this data by grouping by the gene name and sample  columnns, and summarise with sum

```{r}

tx2gene %>% 
    filter( gene_name %in% c( 'DCX' , 'GRM3')) %>% 
    inner_join(tx_exp) %>% 
    select(-transcript_id) %>% 
    pivot_longer(cols = -gene_name, 
                 names_to = 'sample_id',
                 values_to = 'expression') %>% 
    group_by(gene_name, sample_id) %>% 
    summarise(total_expression = sum(expression))

```

- log scale the gene expression data 

```{r}
log2(expression + 1 )

gene_exp_for_plotting <-  tx2gene %>% 
    inner_join(tx_exp) %>% 
    select(-transcript_id) %>% 
    pivot_longer(cols = -gene_name, 
                 names_to = 'sample_id',
                 values_to = 'expression') %>% 
    group_by(gene_name, sample_id) %>% 
    summarise(total_expression = sum(expression)) %>% 
    mutate(log2_expression = log2(total_expression + 1))
    
```


- plot the gene expression data with a boxplot 

```{r}

ggplot(gene_exp_for_plotting) + 
    geom_boxplot(aes(x=gene_name, y=log2_expression, fill = gene_name)) + 
    xlab('Gene Name') + 
    ylab('log2 expression')+
    guides(fill = guide_legend(title = 'Gene Name'))+
    theme_minimal()

```



